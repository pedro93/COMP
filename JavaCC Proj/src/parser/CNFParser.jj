/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CNFParser.jj */
/*@egen*/options 
{ 
 LOOKAHEAD=1; 
} 
 
PARSER_BEGIN(CNFParser) 

package parser;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.List;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;

import common.Structure;
import common.Type;
import algorithm.CYK;
import algorithm.ChomskyConverter;

public class CNFParser implements/*@bgen(jjtree)*/ CNFParserTreeConstants, /*@egen*/ Runnable
{/*@bgen(jjtree)*/
  protected static JJTCNFParserState jjtree = new JJTCNFParserState();

/*@egen*/

	private TreeMap<Structure, List<Vector<Structure>>> SymbolTable = new TreeMap<Structure,List<Vector<Structure>>>();
	private Vector<Structure> AcessableTokens = new Vector<Structure>();
	private Vector<String> toProcess = new Vector<String>();
	private String filePath;
	private File grammarFile;
	
	public boolean isValid=false;
	public boolean saveSucessful=false;


	public CNFParser(String path) throws FileNotFoundException
	{
		this(new FileInputStream(new File(path)), null);
		this.filePath = path;
		grammarFile=new File(filePath);
	}

	@Override
	public void run()
	{
		try {
			SimpleNode root = Expression(); // devolve refer\u00c3\u00aancia para o n\u00c3\u00b3 raiz da \u00c3\u00a0rvore 

			//Create Symbol Table
			this.createSymbolTable(root);
			
			this.SemanticAnalysis();
			
			if(!isValid)
				return;
			
			System.out.println("Symbol table size: "+SymbolTable.size());
			printSymbolTable();

			ChomskyConverter cnf = new ChomskyConverter(SymbolTable) ;
			Vector < Vector <String >> productions = new Vector < Vector<String >>() ;  
			productions = cnf.CNFconverter() ;
			saveGrammarToFile( productions );	
			System.out.println("Data structure from: "+grammarFile.getName()+" parsed and validated, next run CYK Algorithm");
			

		}catch(ParseException i){
			i.printStackTrace();
		}
		catch (Exception e) {
			System.out.println(e.toString());
			e.printStackTrace();
		}
	}

	public void saveGrammarToFile( Vector<Vector<String >>productions ){
		String fileName = grammarFile.getName().substring(0, grammarFile.getName().lastIndexOf("."));

		System.out.println("Saving "+fileName);
		FileOutputStream fOut=null;
		ObjectOutputStream oOut=null;

		try{
			//Save to file

			fOut= new FileOutputStream(fileName+".ser");
			oOut = new ObjectOutputStream(fOut);
			oOut.writeObject(productions);
			System.out.println("Save sucessful");
			saveSucessful=true;
		}
		catch(IOException e) {
			System.err.println("Error: "+e.toString());
			e.printStackTrace();
		}
		finally {
			try {
				oOut.flush();
				oOut.close();
				fOut.close();
			}
			catch (IOException e1) {
				e1.printStackTrace();
			}
		}

	}

	void printSymbolTable()
	{
		List<Vector<Structure>> value;
		Structure key;
		System.out.println("TreeHash");
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet())
		{
			value=entry.getValue();
			key=entry.getKey();
			System.out.print("Key: "+key.toString()+" -> Values:");
			for (Vector<Structure> i : value) {
				System.out.print("[");
				for(Structure x:i)
				{
					System.out.print(x.toString()+",");
				}
				System.out.print("]");
			}
			System.out.println();
		}
	}

	void createSymbolTable(SimpleNode node) {
		for(int i=0; i< node.jjtGetNumChildren(); i++) {
			createSymbolTable((SimpleNode) node.jjtGetChild(i));
		}
		if(node.id == CNFParserTreeConstants.JJTSTARTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
				List<Vector<Structure>> aux;
				if(SymbolTable.get(node.Symbol)==null)
				{
					SymbolTable.put(node.Symbol, node.Variables);
				}
				else
				{
					aux = SymbolTable.get(node.Symbol);
					for(Vector<Structure> temp: node.Variables)
						aux.add(temp);
				}
				aux = node.Variables;
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
			}
			else //gramatica n\u00c3\u00a3o permite chegar a este ponto
			{
				System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
				isValid=false;
			}
		}
		else if(node.id == CNFParserTreeConstants.JJTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
				List<Vector<Structure>> aux;
				if(SymbolTable.get(node.Symbol)==null)
				{
					SymbolTable.put(node.Symbol, node.Variables);
				}
				else
				{
					aux = SymbolTable.get(node.Symbol);
					for(Vector<Structure> temp: node.Variables)
						aux.add(temp);
				}
				aux = node.Variables;
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
			}
			else //gramatica n\u00c3\u00a3o permite chegar a este ponto
			{
				System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
				isValid=false;
			}
		}
		else if(node.id==CNFParserTreeConstants.JJTSTRINGTOTEST)
		{
			toProcess.add(node.Symbol.name);
		}
		else if(node.id!=CNFParserTreeConstants.JJTEXPRESSION)
		{
			System.err.println("[Error] Ilegal operator in line "+node.Symbol.line+" ,column "+node.Symbol.column+" !");
			isValid=false;
		}
		else
			isValid=true;
		return;
	}

	void SemanticAnalysis()
	{
		boolean fail=false;
		List<Vector<Structure>> value;
		Structure key;
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
			value= entry.getValue();
			key=entry.getKey();
			if(!Analyse(key))
				System.err.println("[Warning] "+key.type+" "+key.name+" cannot be derived from START attribution, line "+key.line+", column:"+key.column);
			for (Vector<Structure> i : value) {
				for(Structure x:i)
				{
					if(x.type!=Type.NONTERM)
						continue;
					else if(!SymbolTable.containsKey(x))
					{
						System.err.println("[Error] Found "+x.type+": " +x.name+" without production in line "+x.line+", coloumn "+x.column);
						fail=true;
					}
				}
			}
		}
		if(fail)
			isValid=false;
	}

	private boolean Analyse(Structure key) {
		if(key.type!=Type.START)
		{
			if(AcessableTokens.contains(key))
				return true;
			else
				return false;
		}
		return true;
	}

} 
 
PARSER_END(CNFParser) 
 
SKIP :
{
	" " | "\n" | "\r" | "\t"
} 
 
TOKEN: 
{
 //Permite-se tamanhos maior que 1? P.ex: AC (pode-se confundir com nonTerm?)
 < START: "START" >|
 < END: "END" >|
 < ASSIGN: ":=">|
 < ENDPROD: ";">|
 < OR: "|">|
 < STRING: "STRING:">|
 < NonTerm: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>	 |
 < Term: ["a"-"z"](["a"-"z","A"-"Z","0"-"9"])*>
}
 
SimpleNode Expression(): {/*@bgen(jjtree) Expression */
                          SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(StartAtribution())+ (Atribution())* < STRING > (stringToTest())+< END >/*@bgen(jjtree)*/
                                                                                {
                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                  jjtc000 = false;
                                                                                }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // c\u00c3\u00b3digo Java entre chavetas 
}

void stringToTest():{/*@bgen(jjtree) stringToTest */
                     SimpleNode jjtn000 = new SimpleNode(JJTSTRINGTOTEST);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) stringToTest */
 try {
/*@egen*/
 t=< Term >/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
 	jjtn000.Symbol.name = new String(t.image);
	jjtn000.Symbol.line=t.beginLine;
	jjtn000.Symbol.column=t.beginColumn;
	jjtn000.Symbol.type=Type.STRING;
  }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void StartAtribution():{/*@bgen(jjtree) StartAtribution */
                         SimpleNode jjtn000 = new SimpleNode(JJTSTARTATRIBUTION);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token lhs,rhs; }
{/*@bgen(jjtree) StartAtribution */
        try {
/*@egen*/
	lhs=<START> <ASSIGN>
	{
		jjtn000.Symbol.name = new String(lhs.image);
		jjtn000.Symbol.line=lhs.beginLine;
		jjtn000.Symbol.column=lhs.beginColumn;
		jjtn000.Symbol.type=Type.START;
	}
	(
	  	rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
	|
		(
		  rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
		|
		  rhs=<START>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.START,rhs.beginLine,rhs.beginColumn));}
		)
	)+
	(<OR>
	{jjtn000.Variables.add(new Vector<Structure >());}
		(
			rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
		|
			(
			  rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
			|
			  rhs=<START>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.START,rhs.beginLine,rhs.beginColumn));}
			)
		)+
	)*
	<ENDPROD>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Atribution():{/*@bgen(jjtree) Atribution */
                   SimpleNode jjtn000 = new SimpleNode(JJTATRIBUTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token lhs,rhs;}
{/*@bgen(jjtree) Atribution */
        try {
/*@egen*/
  	lhs=<NonTerm> <ASSIGN>
	{
		jjtn000.Symbol.name = new String(lhs.image);
		jjtn000.Symbol.line=lhs.beginLine;
		jjtn000.Symbol.column=lhs.beginColumn;
		jjtn000.Symbol.type=Type.NONTERM;
	}
	(
	  	rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
	|
		(
		  rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
		|
		  rhs=<START>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.START,rhs.beginLine,rhs.beginColumn));}
		)
	)+
	(<OR>
	{jjtn000.Variables.add(new Vector<Structure >());}
		(
			rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
		|
			(
			  rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
			|
			  rhs=<START>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.START,rhs.beginLine,rhs.beginColumn));}
			)
		)+
	)*
	<ENDPROD>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
