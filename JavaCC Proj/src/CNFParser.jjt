options 
{ 
 LOOKAHEAD=1; 
} 
 
PARSER_BEGIN(CNFParser) 

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.Vector;
import java.lang.String;

public class CNFParser 
{

static HashMap<Structure, List<Vector<Structure>>> SymbolTable = new HashMap<Structure,List<Vector<Structure>>>();
static Vector<Structure> AcessableTokens = new Vector<Structure>();
static Vector<String> toProcess = new Vector<String>();

public static void main(String args[]) throws ParseException,FileNotFoundException { 
	 CNFParser myParser = new CNFParser(new FileInputStream(new File("grammar.txt")));

	 try {
			SimpleNode root = myParser.Expression(); // devolve referência para o nó raiz da árvore 

			//Create Symbol Table
			myParser.createSymbolTable(root);
			myParser.SemanticAnalysis();

			System.out.println("Symbol table size: "+SymbolTable.size());
			root.dump(""); // imprime no ecra a arvore

			Algoritm alg = new Algoritm(SymbolTable);
			if(alg.CYKparser(toProcess))
			{
				System.out.println("Great Success");
			}
			else
			{
				System.out.println("LOL NOT");
			}
		} catch (Exception e) {
			System.err.println(e.toString());
			System.exit(-1);
		}
 }

void createSymbolTable(SimpleNode node) {
        for(int i=0; i< node.jjtGetNumChildren(); i++) {
           createSymbolTable((SimpleNode) node.jjtGetChild(i));
        }
        if(node.id == CNFParserTreeConstants.JJTSTARTATRIBUTION) {			if(node.Variables.size()!=0)
			{
           		List<Vector<Structure>> aux;
           		if(SymbolTable.get(node.Symbol)==null)
           			aux = new LinkedList<Vector<Structure >>();
           		else
           		  	aux= SymbolTable.get(node.Symbol);
				aux.add(node.Variables);
				SymbolTable.put(node.Symbol, aux);
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
       		}
       		else //gramatica não permite chegar a este ponto
       		{
	       		System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
	       		System.exit(1);
       		}
      	}
        else if(node.id == CNFParserTreeConstants.JJTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
           		List<Vector<Structure>> aux;
           		if(SymbolTable.get(node.Symbol)==null)
           			aux = new LinkedList<Vector<Structure >>();
           		else
           		  	aux= SymbolTable.get(node.Symbol);
				aux.add(node.Variables);
				SymbolTable.put(node.Symbol, aux);
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
       		}
       		else //gramatica não permite chegar a este ponto
       		{
	       		System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
	       		System.exit(1);
       		}
        }
       	else if(node.id==CNFParserTreeConstants.JJTSTRINGTOTEST)
		{
			toProcess.add(node.Symbol.name);
		}
        else if(node.id!=CNFParserTreeConstants.JJTEXPRESSION)        {
			System.err.println("[Error] Ilegal operator in line "+node.Symbol.line+" ,column "+node.Symbol.column+" !");
	 		System.exit(1);        }
        return;
  }

	void SemanticAnalysis()
	{
		boolean fail=false;
		List<Vector<Structure>> value;
		Structure key;
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
			value= entry.getValue();
			key=entry.getKey();
			if(!Analyse(key))
				System.err.println("[Warning] "+key.type+" "+key.name+" cannot be derived from START attribution, line "+key.line+", column:"+key.column);
			for (Vector<Structure> i : value) {
				for(Structure x:i)
				{
					if(x.type!=Type.NONTERM)
						continue;
					else if(!SymbolTable.containsKey(x))
					{
						System.err.println("[Error] Found "+x.type+": " +x.name+" without production in line "+x.line+", coloumn "+x.column);
						fail=true;
					}
				}
			}
		}
		if(fail)
			System.exit(-1);
	}

	private boolean Analyse(Structure key) {
	if(key.type!=Type.START)
	{	  if(AcessableTokens.contains(key))
		return true;
	else
		return false;
	}
	return true;	
	}
} 
 
PARSER_END(CNFParser) 
 
SKIP :
{
	" " | "\n" | "\r" | "\t"
} 
 
TOKEN: 
{
 //Permite-se tamanhos maior que 1? P.ex: AC (pode-se confundir com nonTerm?)
 < START: "START" >|
 < END: "END" >|
 < STRING: "STRING:">|
 < NonTerm: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>	 |
 < Term: ["a"-"z"](["a"-"z","A"-"Z","0"-"9"])*>
}
 
SimpleNode Expression(): {} 
{
	(StartAtribution())+ (Atribution())* < STRING > (stringToTest())+< END >{return jjtThis;} // código Java entre chavetas 
}

void stringToTest():{Token t;}{
 t=< Term >
 {
 	jjtThis.Symbol.name = new String(t.image);
	jjtThis.Symbol.line=t.beginLine;
	jjtThis.Symbol.column=t.beginColumn;
	jjtThis.Symbol.type=Type.STRING;  }
}

void StartAtribution():{Token t,t1,t2;}
{	t=<START> ":="
	{
		jjtThis.Symbol.name = new String(t.image);
		jjtThis.Symbol.line=t.beginLine;
		jjtThis.Symbol.column=t.beginColumn;
		jjtThis.Symbol.type=Type.START;
	}

	((t1=<NonTerm >
	{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));}	t2=<NonTerm >
	{jjtThis.Variables.add(new Structure(t2.image,Type.NONTERM,t2.beginLine,t2.beginColumn));})
	|
	(t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})) ";"
	
   /*
	(((t1=<NonTerm>{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));})
	+ (t2=<Term>{jjtThis.Variables.add(new Structure(t2.image,Type.TERM,t2.beginLine,t2.beginColumn));})*) |
	(t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})+) ";"
	*/
}

void Atribution():{Token t,t1,t2;}
{
  //S:= tu e o gato NP VP
  //VP:=Det
  //Det:= tu
  //VP:= e o gato
  
  //SYMBOL:=(NonTerm)+ (Term)* | (Term)+;
      t=<NonTerm> ":="
   {
   jjtThis.Symbol.name = new String(t.image);
   jjtThis.Symbol.line=t.beginLine;
   jjtThis.Symbol.column=t.beginColumn;
   jjtThis.Symbol.type=Type.NONTERM;
   }

	((t1=<NonTerm >
	{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));}
	t2=<NonTerm >
	{jjtThis.Variables.add(new Structure(t2.image,Type.NONTERM,t2.beginLine,t2.beginColumn));})
	|
	(t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})) ";"
   /* (((t1=<NonTerm>{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));})
 + (t2=<Term>{jjtThis.Variables.add(new Structure(t2.image,Type.TERM,t2.beginLine,t2.beginColumn));})*) 
	|
 (t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})+) ";"*/}

