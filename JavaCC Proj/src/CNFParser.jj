/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CNFParser.jj */
/*@egen*/options 
{ 
 LOOKAHEAD=1; 
} 
 
PARSER_BEGIN(CNFParser) 

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.Vector;
import java.lang.String;

public class CNFParser/*@bgen(jjtree)*/implements CNFParserTreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected static JJTCNFParserState jjtree = new JJTCNFParserState();

/*@egen*/

static HashMap<Structure, List<Vector<Structure>>> SymbolTable = new HashMap<Structure,List<Vector<Structure>>>();

public static void main(String args[]) throws ParseException,FileNotFoundException { 
	 CNFParser myParser = new CNFParser(new FileInputStream(new File("grammar.txt")));
	 SimpleNode root = myParser.Expression(); // devolve refer\u00eancia para o n\u00f3 raiz da \u00e1rvore 

	//Create Symbol Table
     myParser.createSymbolTable(root);
     myParser.SemanticAnalysis();

	 System.out.println("Tamanho da hash: "+SymbolTable.size());
	 root.dump(""); // imprime no ecr\u00e3 a \u00e1rvore
     System.out.println(SymbolTable.toString());
 }

void createSymbolTable(SimpleNode node) {
        for(int i=0; i< node.jjtGetNumChildren(); i++) {
           createSymbolTable((SimpleNode) node.jjtGetChild(i));
        }		
        if(node.id == CNFParserTreeConstants.JJTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
           		List<Vector<Structure>> aux;
           		if(SymbolTable.get(node.Symbol)==null)
           			aux = new LinkedList<Vector<Structure >>();
           		else
           		  	aux= SymbolTable.get(node.Symbol);
				aux.add(node.Variables);
				SymbolTable.put(node.Symbol, aux);
				return;
       		}
       		else //gramatica n\u00e3o permite chegar a este ponto
       		{
	       		System.out.println("Atribui\u00e7\u00e3o inv\u00e1lida na linha "+node.Symbol.line+" ,coluna "+node.Symbol.column);
	       		System.exit(1);
       		}
        }
        else if(node.id!=CNFParserTreeConstants.JJTEXPRESSION)        {
          	System.out.println("Operador ilegal!"); 
	 		System.exit(1);        }
        return;
  }

void SemanticAnalysis()
{
	List<Vector<Structure>> value;
	for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
		value= entry.getValue();
        for (Vector<Structure> i : value) {
    	    for(Structure x:i)
            {
				if(x.name.substring(0,1).matches("[a-z]"))
					continue;
                else if(!SymbolTable.containsKey(x))
				{
					System.out.println("Found "+x.type+": " +x.name+" without production in line "+x.line+", coloumn "+x.column);
					System.exit(1);
				}
			}
		}
	}
}

 /*
int eval(SimpleNode node)
{ 
	if(node.jjtGetNumChildren() == 0) // leaf node with integer value 
 		return node.val; 
 	else if(node.jjtGetNumChildren() == 1) // only one child 
 		return this.eval((SimpleNode) node.jjtGetChild(0)); 
 
 	SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child 
 	SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child 
 
	switch(node.id) { 
	 	case CNFParserTreeConstants.JJTADD : return eval( lhs ) + eval( rhs ); 
	 	case CNFParserTreeConstants.JJTSUB : return eval( lhs ) - eval( rhs ); 
		case CNFParserTreeConstants.JJTMUL : return eval( lhs ) * eval( rhs ); 
		case CNFParserTreeConstants.JJTDIV : return eval( lhs ) / eval( rhs ); 
	 	default : // abort 
	 		System.out.println("Operador ilegal!"); 
	 		System.exit(1); 
 		} 
 	return 0; 
	}
	*/
} 
 
PARSER_END(CNFParser) 
 
SKIP :
{
	" " | "\n" | "\r" | "\t"
} 
 
TOKEN: 
{ 
 < AT: ":="> |
 < END: "END" >|
 //< SYMBOL: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])* > | //Permiti-se tamanhos maior que 1? P.ex: AC (pode-se confundir com nonTerm?)
 < NonTerm: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>	 |
 < Term: ["a"-"z"](["a"-"z","A"-"Z","0"-"9"])*>
}
 
SimpleNode Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Expression */
         try {
/*@egen*/ 
	 (Atribution())+ < END >/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/ // c\u00f3digo Java entre chavetas 
}

void Atribution():{/*@bgen(jjtree) Atribution */
                   SimpleNode jjtn000 = new SimpleNode(JJTATRIBUTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t,t1,t2;}
{/*@bgen(jjtree) Atribution */
   try {
/*@egen*/
  //S:= tu e o gato NP VP
  //VP:=Det
  //Det:= tu
  //VP:= e o gato
  
  //SYMBOL:=(NonTerm)+ (Term)* | (Term)+;
      t=<NonTerm> ":="
   {
   jjtn000.Symbol.name = new String(t.image);
   jjtn000.Symbol.line=t.beginLine;
   jjtn000.Symbol.column=t.beginColumn;
   jjtn000.Symbol.type=Type.NONTERM;
   }
    (((t1=<NonTerm>{jjtn000.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));})
 + (t2=<Term>{jjtn000.Variables.add(new Structure(t2.image,Type.TERM,t2.beginLine,t2.beginColumn));})*) 
	|
 (t1=<Term>{jjtn000.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})+) ";"/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/}

