/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CNFParser.jj */
/*@egen*/options 
{ 
 LOOKAHEAD=1; 
} 
 
PARSER_BEGIN(CNFParser) 

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.List;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;

public class CNFParser/*@bgen(jjtree)*/implements CNFParserTreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected static JJTCNFParserState jjtree = new JJTCNFParserState();

/*@egen*/

static TreeMap<Structure, List<Vector<Structure>>> SymbolTable = new TreeMap<Structure,List<Vector<Structure>>>();
static Vector<Structure> AcessableTokens = new Vector<Structure>();
static Vector<String> toProcess = new Vector<String>();

public static void main(String args[]) throws FileNotFoundException{
  	try {
			CNFParser myParser = new CNFParser(new FileInputStream(new File("grammar.txt")));

			SimpleNode root = myParser.Expression(); // devolve refer\u00c3\u00aancia para o n\u00c3\u00b3 raiz da \u00c3\u00a0rvore 

			//Create Symbol Table
			myParser.createSymbolTable(root);
			myParser.SemanticAnalysis();

			System.out.println("Symbol table size: "+SymbolTable.size());
			printSymbolTable();
			//root.dump(""); // imprime no ecra a arvore

			saveGrammarToFile();
            Algoritm alg = new Algoritm();
			if(alg.CYKparser(toProcess))
			{
				System.out.println("Great Success");
			}
			else
			{
				System.out.println("LOL NOT");
			}

			//ChomskyConverter chomsky = new ChomskyConverter(SymbolTable) ;
			//chomsky.CNFconverter() ;

		} catch (Exception e) {
			System.out.println(e.toString());
			e.printStackTrace();
			System.exit(0);
		}
 }

static void saveGrammarToFile(){
		FileOutputStream fOut=null;
        ObjectOutputStream oOut=null;
        
        Vector<Vector<String>> productions = new Vector<Vector<String>>();
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
			List<Vector<Structure>> value = entry.getValue();
			Structure key = entry.getKey();
			for (Vector<Structure> i : value) {
				Vector<String> toAdd = new Vector<String>();
				toAdd.add(key.name);
				toAdd.add(":=");
				for(Structure x:i)
				{
					toAdd.add(x.name);
				}
				productions.add(toAdd);
			}
		}
        
        try{
            //Save to file A.ser
            fOut= new FileOutputStream("A.ser");
            oOut = new ObjectOutputStream(fOut);
            oOut.writeObject(productions);
        }
        catch(IOException e) {
            e.printStackTrace();
        }
        finally {
            try {
                oOut.flush();
                oOut.close();
                fOut.close();
            }
            catch (IOException e1) {
                e1.printStackTrace();
            }
        }
        
	}
 
static void printSymbolTable()
	{
		List<Vector<Structure>> value;
		Structure key;
		System.out.println("TreeHash");
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet())
		{
			value=entry.getValue();
			key=entry.getKey();
			System.out.print("\tKey: "+key.toString()+"\n\t\tValues:");
			for (Vector<Structure> i : value) {
				System.out.print("[");
				for(Structure x:i)
				{
					System.out.print(x.toString()+",");
				}
				System.out.print("]");
			}
			System.out.println();
		}
	}

void createSymbolTable(SimpleNode node) {
		for(int i=0; i< node.jjtGetNumChildren(); i++) {
			createSymbolTable((SimpleNode) node.jjtGetChild(i));
		}
		if(node.id == CNFParserTreeConstants.JJTSTARTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
				List<Vector<Structure>> aux;
				if(SymbolTable.get(node.Symbol)==null)
				{
					SymbolTable.put(node.Symbol, node.Variables);
				}
				else
				{
					aux = SymbolTable.get(node.Symbol);
					for(Vector<Structure> temp: node.Variables)
						aux.add(temp);
				}
				aux = node.Variables;
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
			}
			else //gramatica n\u00c3\u00a3o permite chegar a este ponto
			{
				System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
				System.exit(1);
			}
		}
		else if(node.id == CNFParserTreeConstants.JJTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
				List<Vector<Structure>> aux;
				if(SymbolTable.get(node.Symbol)==null)
				{
					SymbolTable.put(node.Symbol, node.Variables);
				}
				else
				{
					aux = SymbolTable.get(node.Symbol);
					for(Vector<Structure> temp: node.Variables)
						aux.add(temp);
				}
				aux = node.Variables;
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);	
					}
				}
				return;
			}
			else //gramatica n\u00c3\u00a3o permite chegar a este ponto
			{
				System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
				System.exit(1);
			}
		}
		else if(node.id==CNFParserTreeConstants.JJTSTRINGTOTEST)
		{
			toProcess.add(node.Symbol.name);
		}
		else if(node.id!=CNFParserTreeConstants.JJTEXPRESSION)
		{
			System.err.println("[Error] Ilegal operator in line "+node.Symbol.line+" ,column "+node.Symbol.column+" !");
			System.exit(1);
		}
		return;
	}

void SemanticAnalysis()
	{
		boolean fail=false;
		List<Vector<Structure>> value;
		Structure key;
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
			value= entry.getValue();
			key=entry.getKey();
			if(!Analyse(key))
				System.err.println("[Warning] "+key.type+" "+key.name+" cannot be derived from START attribution, line "+key.line+", column:"+key.column);
			for (Vector<Structure> i : value) {
				for(Structure x:i)
				{
					if(x.type!=Type.NONTERM)
						continue;
					else if(!SymbolTable.containsKey(x))
					{
						System.err.println("[Error] Found "+x.type+": " +x.name+" without production in line "+x.line+", coloumn "+x.column);
						fail=true;
					}
				}
			}
		}
		if(fail)
			System.exit(-1);
	}

private boolean Analyse(Structure key) {
	if(key.type!=Type.START)
	{
	  if(AcessableTokens.contains(key))
		return true;
	else
		return false;
	}
	return true;	
	}
} 
 
PARSER_END(CNFParser) 
 
SKIP :
{
	" " | "\n" | "\r" | "\t"
} 
 
TOKEN: 
{
 //Permite-se tamanhos maior que 1? P.ex: AC (pode-se confundir com nonTerm?)
 < START: "START" >|
 < END: "END" >|
 < ASSIGN: ":=">|
 < ENDPROD: ";">|
 < OR: "|">|
 < STRING: "STRING:">|
 < NonTerm: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>	 |
 < Term: ["a"-"z"](["a"-"z","A"-"Z","0"-"9"])*>
}
 
SimpleNode Expression(): {/*@bgen(jjtree) Expression */
                          SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(StartAtribution())+ (Atribution())* < STRING > (stringToTest())+< END >/*@bgen(jjtree)*/
                                                                                {
                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                  jjtc000 = false;
                                                                                }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // c\u00c3\u00b3digo Java entre chavetas 
}

void stringToTest():{/*@bgen(jjtree) stringToTest */
                     SimpleNode jjtn000 = new SimpleNode(JJTSTRINGTOTEST);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) stringToTest */
 try {
/*@egen*/
 t=< Term >/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
 	jjtn000.Symbol.name = new String(t.image);
	jjtn000.Symbol.line=t.beginLine;
	jjtn000.Symbol.column=t.beginColumn;
	jjtn000.Symbol.type=Type.STRING;
  }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void StartAtribution():{/*@bgen(jjtree) StartAtribution */
                         SimpleNode jjtn000 = new SimpleNode(JJTSTARTATRIBUTION);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token lhs,rhs; }
{/*@bgen(jjtree) StartAtribution */
        try {
/*@egen*/	lhs=<START> <ASSIGN>
	{
		jjtn000.Symbol.name = new String(lhs.image);
		jjtn000.Symbol.line=lhs.beginLine;
		jjtn000.Symbol.column=lhs.beginColumn;
		jjtn000.Symbol.type=Type.START;
	}
	(
	  	rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
	|
		rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
	)+
	(<OR>	{jjtn000.Variables.add(new Vector<Structure >());}
		(
			rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
		|
			rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
		)+
	)*
	<ENDPROD>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

void Atribution():{/*@bgen(jjtree) Atribution */
                   SimpleNode jjtn000 = new SimpleNode(JJTATRIBUTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token lhs,rhs;}
{/*@bgen(jjtree) Atribution */
        try {
/*@egen*/
  	lhs=<NonTerm> <ASSIGN>
	{
		jjtn000.Symbol.name = new String(lhs.image);
		jjtn000.Symbol.line=lhs.beginLine;
		jjtn000.Symbol.column=lhs.beginColumn;
		jjtn000.Symbol.type=Type.NONTERM;
	}
	(
	  	rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
	|
		rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
	)+
	(<OR>
	{jjtn000.Variables.add(new Vector<Structure >());}
		(
			rhs=<Term>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.TERM,rhs.beginLine,rhs.beginColumn));}
		|
			rhs=<NonTerm>{jjtn000.Variables.get(jjtn000.Variables.size()-1).add(new Structure(rhs.image,Type.NONTERM,rhs.beginLine,rhs.beginColumn));}
		)+
	)*
	<ENDPROD>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

