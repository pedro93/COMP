/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CNFParser.jj */
/*@egen*/options 
{ 
 LOOKAHEAD=1; 
} 
 
PARSER_BEGIN(CNFParser) 

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;
import java.lang.String;

public class CNFParser/*@bgen(jjtree)*/implements CNFParserTreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected static JJTCNFParserState jjtree = new JJTCNFParserState();

/*@egen*/

static TreeMap<Structure, List<Vector<Structure>>> SymbolTable = new TreeMap<Structure,List<Vector<Structure>>>();
static Vector<Structure> AcessableTokens = new Vector<Structure>();
static Vector<String> toProcess = new Vector<String>();

public static void main(String args[]) throws ParseException,FileNotFoundException { 
	 CNFParser myParser = new CNFParser(new FileInputStream(new File("grammar2.txt")));

	 try {
			SimpleNode root = myParser.Expression(); // devolve refer\u00eancia para o n\u00f3 raiz da \u00e1rvore 

			//Create Symbol Table
			myParser.createSymbolTable(root);
			myParser.SemanticAnalysis();

			System.out.println("Symbol table size: "+SymbolTable.size());
			root.dump(""); // imprime no ecra a arvore

			Algoritm alg = new Algoritm(SymbolTable);
			if(alg.CYKparser(toProcess))
			{
				System.out.println("Great Success");
			}
			else
			{
				System.out.println("LOL NOT");
			}
		} catch (Exception e) {
			System.err.println(e.toString());
			System.exit(-1);
		}
 }

void createSymbolTable(SimpleNode node) {
        for(int i=0; i< node.jjtGetNumChildren(); i++) {
           createSymbolTable((SimpleNode) node.jjtGetChild(i));
        }
        if(node.id == CNFParserTreeConstants.JJTSTARTATRIBUTION) {			if(node.Variables.size()!=0)
			{
           		List<Vector<Structure>> aux;
           		if(SymbolTable.get(node.Symbol)==null)
           			aux = new LinkedList<Vector<Structure >>();
           		else
           		  	aux= SymbolTable.get(node.Symbol);
				aux.add(node.Variables);
				SymbolTable.put(node.Symbol, aux);
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
       		}
       		else //gramatica n\u00e3o permite chegar a este ponto
       		{
	       		System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
	       		System.exit(1);
       		}
      	}
        else if(node.id == CNFParserTreeConstants.JJTATRIBUTION) {
			if(node.Variables.size()!=0)
			{
           		List<Vector<Structure>> aux;
           		if(SymbolTable.get(node.Symbol)==null)
           			aux = new LinkedList<Vector<Structure >>();
           		else
           		  	aux= SymbolTable.get(node.Symbol);
				aux.add(node.Variables);
				SymbolTable.put(node.Symbol, aux);
				for (Vector<Structure> temp : aux) {
					for (Structure struct : temp) {
						if(!AcessableTokens.contains(struct))
							AcessableTokens.add(struct);
					}
				}
				return;
       		}
       		else //gramatica n\u00e3o permite chegar a este ponto
       		{
	       		System.err.println("[Error] Invalid attribution in line "+node.Symbol.line+" ,column "+node.Symbol.column);
	       		System.exit(1);
       		}
        }
       	else if(node.id==CNFParserTreeConstants.JJTSTRINGTOTEST)
		{
			toProcess.add(node.Symbol.name);
		}
        else if(node.id!=CNFParserTreeConstants.JJTEXPRESSION)        {
			System.err.println("[Error] Ilegal operator in line "+node.Symbol.line+" ,column "+node.Symbol.column+" !");
	 		System.exit(1);        }
        return;
  }

	void SemanticAnalysis()
	{
		boolean fail=false;
		List<Vector<Structure>> value;
		Structure key;
		for(Entry<Structure, List<Vector<Structure>>> entry : SymbolTable.entrySet()) {
			value= entry.getValue();
			key=entry.getKey();
			if(!Analyse(key))
				System.err.println("[Warning] "+key.type+" "+key.name+" cannot be derived from START attribution, line "+key.line+", column:"+key.column);
			for (Vector<Structure> i : value) {
				for(Structure x:i)
				{
					if(x.type!=Type.NONTERM)
						continue;
					else if(!SymbolTable.containsKey(x))
					{
						System.err.println("[Error] Found "+x.type+": " +x.name+" without production in line "+x.line+", coloumn "+x.column);
						fail=true;
					}
				}
			}
		}
		if(fail)
			System.exit(-1);
	}

	private boolean Analyse(Structure key) {
	if(key.type!=Type.START)
	{	  if(AcessableTokens.contains(key))
		return true;
	else
		return false;
	}
	return true;	
	}
} 
 
PARSER_END(CNFParser) 
 
SKIP :
{
	" " | "\n" | "\r" | "\t"
} 
 
TOKEN: 
{
 //Permite-se tamanhos maior que 1? P.ex: AC (pode-se confundir com nonTerm?)
 < START: "START" >|
 < END: "END" >|
 < STRING: "STRING:">|
 < NonTerm: ["A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>	 |
 < Term: ["a"-"z"](["a"-"z","A"-"Z","0"-"9"])*>
}
 
SimpleNode Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(StartAtribution())+ (Atribution())* < STRING > (stringToTest())+< END >/*@bgen(jjtree)*/
                                                                                {
                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                  jjtc000 = false;
                                                                                }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // c\u00f3digo Java entre chavetas 
}

void stringToTest():{/*@bgen(jjtree) stringToTest */
                     SimpleNode jjtn000 = new SimpleNode(JJTSTRINGTOTEST);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) stringToTest */
 try {
/*@egen*/
 t=< Term >/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
 	jjtn000.Symbol.name = new String(t.image);
	jjtn000.Symbol.line=t.beginLine;
	jjtn000.Symbol.column=t.beginColumn;
	jjtn000.Symbol.type=Type.STRING;  }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void StartAtribution():{/*@bgen(jjtree) StartAtribution */
                        SimpleNode jjtn000 = new SimpleNode(JJTSTARTATRIBUTION);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t,t1,t2;}
{/*@bgen(jjtree) StartAtribution */
        try {
/*@egen*/	t=<START> ":="
	{
		jjtn000.Symbol.name = new String(t.image);
		jjtn000.Symbol.line=t.beginLine;
		jjtn000.Symbol.column=t.beginColumn;
		jjtn000.Symbol.type=Type.START;
	}

	((t1=<NonTerm >
	{jjtn000.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));}	t2=<NonTerm >
	{jjtn000.Variables.add(new Structure(t2.image,Type.NONTERM,t2.beginLine,t2.beginColumn));})
	|
	(t1=<Term>{jjtn000.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})) ";"/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
   /*
	(((t1=<NonTerm>{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));})
	+ (t2=<Term>{jjtThis.Variables.add(new Structure(t2.image,Type.TERM,t2.beginLine,t2.beginColumn));})*) |
	(t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})+) ";"
	*/
}

void Atribution():{/*@bgen(jjtree) Atribution */
                   SimpleNode jjtn000 = new SimpleNode(JJTATRIBUTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t,t1,t2;}
{/*@bgen(jjtree) Atribution */
   try {
/*@egen*/
  //S:= tu e o gato NP VP
  //VP:=Det
  //Det:= tu
  //VP:= e o gato
  
  //SYMBOL:=(NonTerm)+ (Term)* | (Term)+;
      t=<NonTerm> ":="
   {
   jjtn000.Symbol.name = new String(t.image);
   jjtn000.Symbol.line=t.beginLine;
   jjtn000.Symbol.column=t.beginColumn;
   jjtn000.Symbol.type=Type.NONTERM;
   }

	((t1=<NonTerm >
	{jjtn000.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));}
	t2=<NonTerm >
	{jjtn000.Variables.add(new Structure(t2.image,Type.NONTERM,t2.beginLine,t2.beginColumn));})
	|
	(t1=<Term>{jjtn000.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})) ";"/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
   /* (((t1=<NonTerm>{jjtThis.Variables.add(new Structure(t1.image,Type.NONTERM,t1.beginLine,t1.beginColumn));})
 + (t2=<Term>{jjtThis.Variables.add(new Structure(t2.image,Type.TERM,t2.beginLine,t2.beginColumn));})*) 
	|
 (t1=<Term>{jjtThis.Variables.add(new Structure(t1.image,Type.TERM,t1.beginLine,t1.beginColumn));})+) ";"*/}

